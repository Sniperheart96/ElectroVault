# Internationalisierung (i18n)

> Mehrsprachigkeit in ElectroVault - IST-Zustand der Implementierung

## Übersicht

ElectroVault nutzt **LocalizedString** für mehrsprachige Datenbank-Inhalte. Alle nutzergenerierten Freitextfelder (Namen, Beschreibungen) werden als JSON in mehreren Sprachen gespeichert.

**Grundprinzipien:**
1. **Mindestens eine Sprache** - Jedes lokalisierte Feld braucht mindestens einen Wert (egal welche Sprache)
2. **Fallback-Kette** - Angefragte Sprache → Englisch → Erste verfügbare Sprache
3. **Keine Zwangsübersetzung** - Deutsche Nutzer können rein deutsche Inhalte erstellen
4. **JSON-basiert** - Flexibel erweiterbar, keine Schema-Änderungen bei neuen Sprachen

---

## Unterstützte Sprachen

| Code | Sprache | Status | Bemerkung |
|------|---------|--------|-----------|
| `en` | English | ✅ Aktiv | Fallback-Sprache (FALLBACK_LOCALE) |
| `de` | Deutsch | ✅ Aktiv | Primäre UI-Sprache |
| `fr` | Français | ✅ Aktiv | - |
| `es` | Español | ✅ Aktiv | - |
| `zh` | 中文 | ✅ Aktiv | Chinesisch (vereinfacht) |

**Definition in Code:**
```typescript
// packages/shared/src/i18n/types.ts
export type Locale = 'en' | 'de' | 'fr' | 'es' | 'zh';

export const FALLBACK_LOCALE: Locale = 'en';

export const SUPPORTED_LOCALES: readonly Locale[] = ['en', 'de', 'fr', 'es', 'zh'] as const;
```

---

## LocalizedString - Datenstruktur

### TypeScript-Interface

```typescript
// packages/shared/src/i18n/types.ts
export interface LocalizedString {
  en?: string;
  de?: string;
  fr?: string;
  es?: string;
  zh?: string;
  [key: string]: string | undefined;
}
```

**Eigenschaften:**
- Alle Sprachen sind optional
- Dynamischer Index-Signature für Erweiterbarkeit
- Mindestens eine Sprache muss gesetzt sein (bei Pflichtfeldern)

### Beispiele

**Nur eine Sprache (Deutsch):**
```json
{
  "de": "Präzisions-Timer-IC"
}
```

**Mehrsprachig:**
```json
{
  "en": "Precision Timer IC",
  "de": "Präzisions-Timer-IC",
  "fr": "Circuit minuterie de précision"
}
```

**Leer (nur bei optionalen Feldern erlaubt):**
```json
{}
```

---

## Zod-Validierung

### Schemas

```typescript
// packages/schemas/src/common.ts

// Basis-Schema ohne Pflicht-Validierung
const LocalizedStringBaseSchema = z.object({
  en: z.string().optional(),
  de: z.string().optional(),
  fr: z.string().optional(),
  es: z.string().optional(),
  zh: z.string().optional(),
});

// Pflichtfeld - Mindestens eine Sprache muss ausgefüllt sein
export const LocalizedStringSchema = LocalizedStringBaseSchema.refine(
  (data) => Object.values(data).some((val) => val && val.length > 0),
  { message: 'At least one language translation is required' }
);

// Optionales Feld - Kann leer sein
export const LocalizedStringLooseSchema = LocalizedStringBaseSchema;

// Nullable/Optional Varianten
export const LocalizedStringOptionalSchema = LocalizedStringSchema.optional();
export const LocalizedStringNullableSchema = LocalizedStringLooseSchema.nullable();
export const LocalizedStringNullableOptionalSchema = LocalizedStringNullableSchema.optional();
```

### Verwendung in Schemas

```typescript
// packages/schemas/src/category.ts
import { LocalizedStringSchema, LocalizedStringNullableSchema } from './common';

export const CategoryCreateSchema = z.object({
  name: LocalizedStringSchema,          // Pflicht, mindestens eine Sprache
  description: LocalizedStringNullableSchema, // Optional, kann null sein
  // ...
});
```

---

## Prisma-Schema

### JSON-Felder

Lokalisierte Felder werden als `Json` gespeichert:

```prisma
// packages/database/prisma/schema.prisma

model CategoryTaxonomy {
  id              String   @id @default(uuid()) @db.Uuid
  name            Json     // LocalizedString
  description     Json?    // LocalizedString
  levelLabel      Json?    // LocalizedString
  // ...
}

model CoreComponent {
  id                 String   @id @default(uuid()) @db.Uuid
  name               Json     // LocalizedString
  shortDescription   Json?    // LocalizedString
  fullDescription    Json?    // LocalizedString
  // ...
}

model AttributeDefinition {
  id              String   @id @default(uuid()) @db.Uuid
  name            String   @db.VarChar(255) // Technischer Key (nicht lokalisiert!)
  displayName     Json     // LocalizedString
  // ...
}

model ManufacturerPart {
  id     String  @id @default(uuid()) @db.Uuid
  notes  Json?   // LocalizedString
  // ...
}

model PinDefinition {
  id           String   @id @default(uuid()) @db.Uuid
  pinFunction  Json?    // LocalizedString
  // ...
}
```

### Seed-Daten Beispiel

```typescript
// packages/database/prisma/seed.ts
type LocalizedString = {
  en?: string;
  de?: string;
  fr?: string;
  es?: string;
  zh?: string;
};

await prisma.categoryTaxonomy.create({
  data: {
    name: {
      de: 'Kondensatoren',
      en: 'Capacitors',
      fr: 'Condensateurs'
    } as LocalizedString,
    description: {
      de: 'Passive Bauelemente zur Speicherung elektrischer Ladung',
      en: 'Passive components for storing electrical charge'
    } as LocalizedString,
    // ...
  }
});
```

---

## Utility-Funktionen

### getLocalizedText()

Hauptfunktion zum Abrufen von lokalisierten Texten mit Fallback-Logik.

```typescript
// packages/shared/src/utils/localization.ts

export function getLocalizedText(
  data: LocalizedString,
  locale: Locale | string = FALLBACK_LOCALE
): string {
  // 1. Versuch: Angefragte Sprache
  if (data[locale as keyof LocalizedString]) {
    return data[locale as keyof LocalizedString]!;
  }

  // 2. Versuch: Fallback-Sprache (Englisch)
  if (data[FALLBACK_LOCALE]) {
    return data[FALLBACK_LOCALE]!;
  }

  // 3. Versuch: Erste verfügbare Sprache
  const firstAvailable = Object.values(data).find((val) => val);
  if (firstAvailable) {
    return firstAvailable;
  }

  // Fehlerfall: Keine Übersetzung vorhanden
  console.error('No localized value found for any language', { data, locale });
  return '[MISSING TRANSLATION]';
}
```

**Fallback-Kette:**
```
Angefragte Sprache (z.B. 'fr')
    ↓ nicht vorhanden
Englisch ('en')
    ↓ nicht vorhanden
Erste verfügbare Sprache (Object.values()[0])
    ↓ keine vorhanden
'[MISSING TRANSLATION]'
```

**Beispiele:**

```typescript
// Daten: { "de": "Kondensator", "en": "Capacitor" }

getLocalizedText(data, 'de')  // → "Kondensator"
getLocalizedText(data, 'en')  // → "Capacitor"
getLocalizedText(data, 'fr')  // → "Capacitor" (Fallback zu Englisch)

// Daten: { "de": "Kondensator" }
getLocalizedText(data, 'fr')  // → "Kondensator" (Fallback zur ersten Sprache)

// Daten: {}
getLocalizedText(data, 'de')  // → "[MISSING TRANSLATION]"
```

### hasTranslation()

Prüft, ob mindestens eine Übersetzung vorhanden ist.

```typescript
export function hasTranslation(data: LocalizedString): boolean {
  return Object.values(data).some((val) => val && val.trim().length > 0);
}
```

**Beispiele:**

```typescript
hasTranslation({ de: 'Test' })              // → true
hasTranslation({ en: 'Test', de: 'Test' })  // → true
hasTranslation({})                          // → false
hasTranslation({ de: '', en: '   ' })       // → false
```

### slugifyLocalized()

Erstellt URL-freundliche Slugs aus lokalisierten Texten.

```typescript
export function slugifyLocalized(
  data: LocalizedString,
  locale: Locale | string = FALLBACK_LOCALE
): string {
  const text = getLocalizedText(data, locale);

  if (text === '[MISSING TRANSLATION]') {
    return 'untitled';
  }

  return text
    .toLowerCase()
    .replace(/[äöüß]/g, (char) => {
      const map: Record<string, string> = { ä: 'ae', ö: 'oe', ü: 'ue', ß: 'ss' };
      return map[char] || char;
    })
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}
```

**Beispiele:**

```typescript
// Daten: { "de": "Kondensator Typ A" }
slugifyLocalized(data, 'de')  // → "kondensator-typ-a"

// Daten: { "de": "Gehäuse für Prüfgerät" }
slugifyLocalized(data, 'de')  // → "gehaeuse-fuer-pruefgeraet"

// Daten: { "en": "Test & Demo (v2.0)" }
slugifyLocalized(data, 'en')  // → "test-demo-v2-0"

// Daten: {}
slugifyLocalized(data, 'de')  // → "untitled"
```

---

## Frontend-Verwendung

### LocalizedInput-Komponente

UI-Komponente zur Eingabe von mehrsprachigen Texten.

```typescript
// apps/web/src/components/forms/localized-input.tsx

interface LocalizedInputProps {
  value: LocalizedString;
  onChange: (value: LocalizedString) => void;
  locales?: string[];          // Standard: ['de', 'en']
  multiline?: boolean;         // Textarea statt Input
  placeholder?: string;
}

export function LocalizedInput({ ... }: LocalizedInputProps) {
  const [activeLocale, setActiveLocale] = useState(locales[0]);
  // ...
  return (
    <div>
      {/* Sprach-Tabs: DE | EN | ... */}
      <div className="flex gap-1 border-b">
        {locales.map((locale) => (
          <Button
            variant={activeLocale === locale ? 'default' : 'ghost'}
            onClick={() => setActiveLocale(locale)}
          >
            {locale.toUpperCase()}
          </Button>
        ))}
      </div>
      {/* Eingabefeld für aktive Sprache */}
      <InputComponent
        value={value[activeLocale] || ''}
        onChange={(e) => onChange({ ...value, [activeLocale]: e.target.value })}
      />
    </div>
  );
}
```

**Verwendung in Dialogen:**

```tsx
// apps/web/src/components/admin/category-dialog.tsx
import { LocalizedInput } from '@/components/forms/localized-input';

<FormField
  control={form.control}
  name="name"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Name</FormLabel>
      <FormControl>
        <LocalizedInput
          value={field.value}
          onChange={field.onChange}
          locales={['de', 'en']}
        />
      </FormControl>
    </FormItem>
  )}
/>
```

### Anzeige von lokalisierten Texten

```tsx
import { getLocalizedText } from '@electrovault/shared/utils/localization';

function ComponentCard({ component }: { component: Component }) {
  const locale = 'de'; // Oder aus User-Settings

  const displayName = getLocalizedText(component.name, locale);
  const description = component.shortDescription
    ? getLocalizedText(component.shortDescription, locale)
    : null;

  return (
    <div>
      <h2>{displayName}</h2>
      {description && <p>{description}</p>}
    </div>
  );
}
```

---

## API-Design

### Request-Format (POST/PUT)

```json
POST /api/v1/categories
{
  "name": {
    "de": "Kondensatoren",
    "en": "Capacitors"
  },
  "description": {
    "de": "Passive Bauelemente zur Speicherung elektrischer Ladung"
  },
  "slug": "capacitors",
  "level": 2
}
```

### Response-Format (GET)

```json
GET /api/v1/categories/550e8400-e29b-41d4-a716-446655440000
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "slug": "capacitors",
  "name": {
    "de": "Kondensatoren",
    "en": "Capacitors",
    "fr": "Condensateurs"
  },
  "description": {
    "de": "Passive Bauelemente zur Speicherung elektrischer Ladung",
    "en": "Passive components for storing electrical charge"
  },
  "level": 2,
  "createdAt": "2025-01-15T10:30:00Z"
}
```

**Wichtig:**
- API gibt **immer** das vollständige LocalizedString-Objekt zurück
- Frontend ist verantwortlich für Sprach-Auflösung via `getLocalizedText()`
- Keine Sprach-Parameter in der API nötig

---

## Betroffene Datenbank-Felder

### Übersicht: Lokalisierte vs. Nicht-lokalisierte Felder

| Modell | Feld | Lokalisiert | Typ | Begründung |
|--------|------|-------------|-----|------------|
| **CategoryTaxonomy** | name | ✅ | Json | "Resistors" vs "Widerstände" |
| | description | ✅ | Json? | Kategoriebeschreibung |
| | levelLabel | ✅ | Json? | "Type" vs "Typ", "Class" vs "Klasse" |
| | slug | ❌ | String | URL-Pfad, technisch |
| | iconUrl | ❌ | String? | MinIO-URL |
| **CoreComponent** | name | ✅ | Json | "Capacitor" vs "Kondensator" |
| | shortDescription | ✅ | Json? | Kurzbeschreibung |
| | fullDescription | ✅ | Json? | Ausführliche Beschreibung |
| | slug | ❌ | String | URL-Pfad |
| **ManufacturerPart** | notes | ✅ | Json? | Herstellerspezifische Hinweise |
| | mpn | ❌ | String | Manufacturer Part Number |
| | imageUrl | ❌ | String? | MinIO-URL |
| **ManufacturerMaster** | name | ❌ | String | Firmenname ist universal |
| | description | ✅ | Json? | Firmenbeschreibung |
| | slug | ❌ | String | URL-Pfad |
| **AttributeDefinition** | name | ❌ | String | Technischer Schlüssel ("capacitance") |
| | displayName | ✅ | Json | "Capacitance" vs "Kapazität" |
| | unit | ❌ | String? | SI-Einheiten ("F", "Ω") universal |
| **PinDefinition** | pinFunction | ✅ | Json? | "Power" vs "Stromversorgung" |
| | pinNumber | ❌ | String | Technischer Wert |

---

## Tests

### Test-Dateien

- `packages/shared/src/utils/localization.test.ts` - Unit-Tests für Lokalisierungsfunktionen
- `packages/schemas/src/schemas.test.ts` - Zod-Schema-Validierung

### Beispiel-Tests

```typescript
// packages/shared/src/utils/localization.test.ts
import { describe, it, expect } from 'vitest';
import { getLocalizedText, hasTranslation, slugifyLocalized } from './localization';

describe('getLocalizedText', () => {
  it('should return text in requested locale', () => {
    const data = { de: 'Hallo Welt', en: 'Hello World' };
    expect(getLocalizedText(data, 'de')).toBe('Hallo Welt');
    expect(getLocalizedText(data, 'en')).toBe('Hello World');
  });

  it('should fallback to English if requested locale not available', () => {
    const data = { en: 'Hello World' };
    expect(getLocalizedText(data, 'de')).toBe('Hello World');
    expect(getLocalizedText(data, 'fr')).toBe('Hello World');
  });

  it('should fallback to first available language if English not available', () => {
    const data = { fr: 'Bonjour le monde' };
    expect(getLocalizedText(data, 'de')).toBe('Bonjour le monde');
  });

  it('should return error indicator if no translation available', () => {
    const data = {};
    expect(getLocalizedText(data, 'de')).toBe('[MISSING TRANSLATION]');
  });
});
```

---

## Erweiterung um neue Sprachen

### Schritte

1. **TypeScript-Typen erweitern** - `packages/shared/src/i18n/types.ts`
   ```typescript
   export type Locale = 'en' | 'de' | 'fr' | 'es' | 'zh' | 'ja';

   export const SUPPORTED_LOCALES: readonly Locale[] =
     ['en', 'de', 'fr', 'es', 'zh', 'ja'] as const;

   export interface LocalizedString {
     en?: string;
     de?: string;
     fr?: string;
     es?: string;
     zh?: string;
     ja?: string;  // NEU
     [key: string]: string | undefined;
   }
   ```

2. **Zod-Schema erweitern** - `packages/schemas/src/common.ts`
   ```typescript
   const LocalizedStringBaseSchema = z.object({
     en: z.string().optional(),
     de: z.string().optional(),
     fr: z.string().optional(),
     es: z.string().optional(),
     zh: z.string().optional(),
     ja: z.string().optional(),  // NEU
   });
   ```

3. **Frontend aktualisieren** - `apps/web/src/components/forms/localized-input.tsx`
   ```tsx
   // Standardmäßig unterstützte Sprachen erweitern
   locales = ['de', 'en', 'ja']  // Japanisch hinzufügen
   ```

**Wichtig:**
- **KEINE Datenbank-Migration nötig** - JSON-Felder sind flexibel
- Bestehende Daten bleiben kompatibel
- Neue Sprache kann sofort verwendet werden

---

## Best Practices

### 1. Immer Fallback-Sprache (Englisch) ausfüllen

```typescript
// ✅ RICHTIG - Englisch als Fallback vorhanden
{
  "de": "Kondensator",
  "en": "Capacitor"
}

// ⚠️ NICHT IDEAL - Nur Deutsch, kein internationaler Fallback
{
  "de": "Kondensator"
}
```

### 2. Technische Felder NICHT lokalisieren

```typescript
// ✅ RICHTIG
{
  "slug": "ne555-timer",          // Nicht lokalisiert
  "name": {
    "de": "555 Timer",
    "en": "555 Timer"
  }
}

// ❌ FALSCH
{
  "slug": {
    "de": "ne555-timer-de",
    "en": "ne555-timer-en"
  }
}
```

### 3. Fehlerbehandlung mit sichtbarem Indikator

```typescript
// ✅ RICHTIG - Fehler ist sichtbar
if (text === '[MISSING TRANSLATION]') {
  return <span className="text-red-500">[Übersetzung fehlt]</span>;
}

// ❌ FALSCH - Dummy-Daten verschleiern Fehler
if (text === '[MISSING TRANSLATION]') {
  return 'Untitled Component';  // VERBOTEN!
}
```

### 4. Leere Strings vermeiden

```typescript
// ✅ RICHTIG - Nur ausgefüllte Sprachen speichern
{
  "de": "Kondensator"
  // 'en' wird nicht gespeichert wenn leer
}

// ❌ FALSCH - Leere Strings speichern
{
  "de": "Kondensator",
  "en": ""  // Vermeiden!
}
```

---

## Zusammenfassung

### Implementierte Features

| Feature | Status | Datei |
|---------|--------|-------|
| LocalizedString Interface | ✅ | `packages/shared/src/i18n/types.ts` |
| Fallback-Logik | ✅ | `packages/shared/src/utils/localization.ts` |
| Zod-Schemas | ✅ | `packages/schemas/src/common.ts` |
| Prisma JSON-Felder | ✅ | `packages/database/prisma/schema.prisma` |
| LocalizedInput-Komponente | ✅ | `apps/web/src/components/forms/localized-input.tsx` |
| Unit-Tests | ✅ | `packages/shared/src/utils/localization.test.ts` |
| Seed-Daten | ✅ | `packages/database/prisma/seed.ts` |

### Unterstützte Sprachen

- **Englisch (en)** - Fallback-Sprache
- **Deutsch (de)** - Primäre UI-Sprache
- **Französisch (fr)**
- **Spanisch (es)**
- **Chinesisch (zh)**

### Kern-Funktionen

1. **getLocalizedText(data, locale)** - Hauptfunktion zum Abrufen von Texten
2. **hasTranslation(data)** - Prüft ob Übersetzung vorhanden
3. **slugifyLocalized(data, locale)** - Erstellt URL-Slugs aus lokalisierten Texten

---

*Siehe auch: [tech-stack.md](tech-stack.md) | [database-schema.md](database-schema.md)*
